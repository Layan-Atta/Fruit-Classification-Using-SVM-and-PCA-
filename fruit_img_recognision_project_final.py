# -*- coding: utf-8 -*-
"""Fruit_IMG_Recognision_Project_Final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RjZn4ovO1e6EhuktERk7jskOXZ_FCB13

#Install and Download Dataset
Because the work is collective, we must upload in a unified way instead of downloading the data every time.
Also The data size is very large, so we use this method after searching.
"""

!pip install -q kaggle
from google.colab import files
files.upload()

!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

"""# **Dataset Description
for this project we used an images dataset from kaggle : [link](https://www.kaggle.com/datasets/karimabdulnabi/fruit-classification10-class)

The dataset contains Fruits images this data is collected by scraping the web.

the dataset is divided into 10 classes
1. Apple
2. Orange
3. Avocado
4. Kiwi
5. Mango
6. Pinenapple
7. Strawberries
8. **Banana**
9. Cherry
10. **Watermelon**



"""

!kaggle datasets download -d karimabdulnabi/fruit-classification10-class

# فك الضغط عنها
!unzip -q fruit-classification10-class.zip

"""# Import Required Libraries
Here are all the libraries we need for preprocessing modeling, visulizing and evaluation.
"""

import os
import numpy as np
import matplotlib.pyplot as plt
from PIL import Image
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.svm import SVC
from sklearn.decomposition import PCA
from sklearn.preprocessing import LabelEncoder, StandardScaler
from sklearn.pipeline import Pipeline
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score
from tqdm import tqdm

"""#Load and Preprocess Images
We selected two fruit classes (Banana and Watermelon) for simplicity and clearer visual distinction. All images are converted to grayscale, resized to 128x128 pixels, and flattened into 1D arrays.
"""

data_dir = "/content/MY_data/train"
target_classes = ['watermelon', 'Banana']

X, y = [], []

for class_name in target_classes:
    class_path = os.path.join(data_dir, class_name)
    for img_file in os.listdir(class_path):
        try:
            img_path = os.path.join(class_path, img_file)
            img = Image.open(img_path).convert('L')
            img = img.resize((128, 128))
            img_array = np.asarray(img).flatten()
            X.append(img_array)
            y.append(class_name)
        except:
            continue

X = np.array(X)
y = np.array(y)
#check
print("X shape:", X.shape)
print("y shape:", y.shape)
print("Classes:", np.unique(y))

"""# Display Sample Images from Each Class"""

labels = np.array(y)
images = np.array(X).reshape(-1, 128, 128)

plt.figure(figsize=(10, 4))

for i, class_name in enumerate(np.unique(labels)):
    # First image for each class
    idx = np.where(labels == class_name)[0][0]
    plt.subplot(1, len(np.unique(labels)), i+1)
    plt.imshow(images[idx], cmap='gray')
    plt.title(class_name)
    plt.axis('off')

plt.tight_layout()
plt.show()

"""# **Normalization & Label Encoding**

**Normalize, Encode Labels, and Apply PCA**

We normalize pixel values to [-1, 1], encode class labels numerically, standardize features, and reduce dimensionality using PCA.
"""

X = X / 255.0 * 2 - 1

label_encoder = LabelEncoder()
y = label_encoder.fit_transform(y)

print("Encoded classes:", dict(zip(label_encoder.classes_, label_encoder.transform(label_encoder.classes_))))

scaler = StandardScaler()
X = scaler.fit_transform(X)

pca = PCA(n_components=300)
X_pca = pca.fit_transform(X)
print("X after PCA:", X_pca.shape)

"""#Split Data and Train SVM Model using GridSearchCV"""

# 80% training, 20% testing
X_train, X_test, y_train, y_test = train_test_split(X_pca, y, test_size=0.2, random_state=42)

"""During model training, we observed a strong bias towards one class due to the imbalance in the dataset (one class having significantly more samples than the other).
To address this challenge, we applied `class_weight='balanced'` in the SVM classifier.
This adjustment automatically assigns higher weights to minority classes and lower weights to majority classes, helping the model to treat all classes fairly and improve overall classification performance.
"""

pipeline = Pipeline([
    ('clf', SVC(kernel='rbf', class_weight='balanced'))
])


params = {
    'clf__C': [1, 10, 30],
    'clf__gamma': [0.001, 0.01, 0.03]
}


grid_search = GridSearchCV(pipeline, params, scoring='accuracy', verbose=1, n_jobs=-1)
grid_search.fit(X_train, y_train)

print("Best Accuracy Score: {:.3f}".format(grid_search.best_score_))
print("Best Parameters:", grid_search.best_params_)

y_pred = grid_search.predict(X_test)

"""# Evaluate Model Performance"""

print("Classification Report:")
print(classification_report(y_test, y_pred, target_names=label_encoder.classes_))
print("Test Accuracy:", accuracy_score(y_test, y_pred))

cm = confusion_matrix(y_test, y_pred)
plt.title("Confusion Matrix")
plt.imshow(cm)
plt.xticks(ticks=np.arange(len(label_encoder.classes_)), labels=label_encoder.classes_, rotation=45)
plt.yticks(ticks=np.arange(len(label_encoder.classes_)), labels=label_encoder.classes_)
plt.colorbar()
plt.xlabel("Predicted")
plt.ylabel("True")
plt.show()

"""# **Practical Testing**

# Predict a Custom Uploaded Image
"""

def predict_image(img_path):
    img = Image.open(img_path).convert("L")
    img = img.resize((128, 128))
    img_array = np.asarray(img).flatten()
    img_array = img_array / 255.0 * 2 - 1
    img_pca = pca.transform([img_array])
    pred = grid_search.predict(img_pca)
    label = label_encoder.inverse_transform(pred)[0]
    plt.imshow(img)
    plt.title(f"Prediction: {label}")
    plt.axis("off")
    plt.show()

# مثال:
predict_image("/content/MY_data/predict/img_141.jpeg")
predict_image("/content/بطيخخ.jpg")